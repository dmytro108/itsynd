### Solution
This solution expands the task by allowing you to create any number of VPCs and create peering connections between these **VPC**s according to the “each to each” scheme.

#### VPCs
The specified number of **VPC**s is configured in the [vpc module](https://registry.terraform.io/modules/terraform-aws-modules/vpc/aws/latest). Despite on the solution is able to create any valid number of VPCs with specified numbers of private and public subnets, only one CIDR prefix is specified. The rest of CIDRs is calculated in the locals section:
```hcl
locals {
  # map of VPC CIDR blocks with private and bublic subnets CIDRs:
  # {vpc_cidr: 10.x.0.0/16
  # private_subnet_cidrs: 10.x.y.0/24
  # public_subnet_cidrs: 10.x.10y.0/24}
  cidrs = [for vcidr in [for x in range(var.vpc_num) : cidrsubnet(var.vpc_cidr_prefix, 4, x)] : {
    vpc_cidr             = vcidr
    private_subnet_cidrs = [for y in range(var.private_subnet_num) : cidrsubnet(vcidr, 8, y)]
    public_subnet_cidrs  = [for y in range(var.public_subnet_num) : cidrsubnet(vcidr, 8, 100 + y)]
  }]
}
```
The whole code dedicated to the VPCs peering is in the file [vpc.tf](vpc.tf)

#### Peering connections
Peering connections between all **VPC**s are then configured using the for_each meta argument. As a parameter for the meta-argument for_each, a special string array is used containing pairs of indexes created by the module, **VPC** - `["0.1", "0.2", "0.3",...,"0,n", ..., "n-1, n"]`. The array is created in the `locals` section and contains all possible combinations of pairs of indexes of another array, which was created by the vpc module. For each **VPC** pair, a resource `aws_vpc_peering_connection` is created where the indexes from each element of the pairs array are used to obtain the **VPC** IDs generated by the *vpc module*.
Routes for the routing tables of each of the subnets in each **VPC** are generated in a similar way. The string *("x,y")* containing the **VPC** index pair is also the key in the peering connection resource set. The CIDR of one of the **VPC**s of the peering pair is used as the destination of each route, and the peering connection itself is used as the gateway. This route is added to the routing table associated with a subnet belonging to another VPC from the same peering pair.
The array of **VPC** pairs generated as following:
```hcl
locals {
  # List of inxes of VPCs which joint into peering pairs: ["0,1",...,"0,n",..., "n-1,n"]
  # The list contains pairs by the scheme "each to each"
  peering_pairs = flatten([for vpc1 in range(var.vpc_num) : [
    for vpc2 in range(vpc1 + 1, var.vpc_num, 1) :
    join(",", [vpc1, vpc2])
    ]
  ])
}
```

All peering connections are configured as following:
```hcl
resource "aws_vpc_peering_connection" "peering" {
  for_each    = toset(local.peering_pairs)
  peer_vpc_id = module.vpc[tonumber(split(",", each.value)[0])].vpc_id
  vpc_id      = module.vpc[tonumber(split(",", each.value)[1])].vpc_id
  auto_accept = true
  tags = {
    Name = "peer-${each.value}"
  }
}
```

A route is configured as following:
```hcl
resource "aws_route" "direct_privat" {
  for_each = toset(keys(aws_vpc_peering_connection.peering))

  route_table_id            = module.vpc[tonumber(split(",", each.value)[1])].private_route_table_ids[0]
  destination_cidr_block    = module.vpc[tonumber(split(",", each.value)[0])].vpc_cidr_block
  vpc_peering_connection_id = aws_vpc_peering_connection.peering[each.value].id
}
```
The whole code dedicated to the VPCs peering is in the file [peering.tf](peering.tf)
